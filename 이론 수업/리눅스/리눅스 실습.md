# 리눅스

Shell 은 os와 사용자간의 메세지를 전달

암호화된 패스워드가 /etc/passwd가 아닌 /etc/shadow에 저장되는 이유

다른 사용자가 passwd는 볼 수있지만 shadow는 볼 수 없다.

shadow파일의 내용 중 줄의 마지막 항목 쉘의 경우 /bin/bash는 원격 접속이 가능하지만 /bin/false는 원겹 접근을 막는 역할을 한다.

# 리눅스 실습

- mount ⇐ VMware Tools CD의 마운팅 경로를 확인

-  cd /media/root/VMware\ Tools



- 리눅스에서는 띄워쓰기가 명령어와 서브명령어를 구분하는 역할을 한다.

- 따라서 cd명령어를 사용할 때 폴더 명에 띄워쓰기가 있으면 공백을 명령어가 아닌 폴더명의 일부로 인식하기 위해 \를 사용해서 escape를 해준다.



- cp *.gz /tmp ⇐ 설치 파일을 작업 디렉터리로 복사

- cd /tmp ⇐ 작업 디렉터리로 이동

- tar -xvf VMware[TABKEY]

- cd vmare[TABKEY]

- ./vmware-install.pl

- 첫번째 질문에 yes를 입력하고 나머지는 엔터(디폴트로 설치)

- 끝나고 나면 reboot



# vi 편집기

vi → 명령어 모드

![](https://cau-dosc.github.io/images/vi-mode-switching.PNG)

- 명령어 모드에서 i(현재커서부터 입력), a(커서다음부터 입력)를 입력하면 편집모드로 들어간다
- 편집모드에서 명령어 모드로 들어오려면 esc키를 누른다.
- 명령어 모드에서 라인명령모드로 들어가려면 : 을 입력한다. 역시 돌아오려면 esc를 누른다.
  - :q (종료) :w (저장) :wq (저장 후 종료) : q!(강제로 종료)
  - /ba ☞ ba로 시작하는 문자열을 찾는다. 다음 문자열 찾기 - n
  - vi편집기를 사용하여 편집하는 도중에 터미널이 종료되면 그 파일의 임시저장(swp)파일이 저장된다.
  - 임시저장 파일은 숨김파일이다. ls -a로 볼 수 있다. linux의 숨김파일은 이름 앞에 . 이 붙는다.



# 명령어 프롬프트

사용자@호스트 : 경로 $#

ex) root@Server-b:~#

명령어들(p.140)

종료하는 방법

- poweroff, shutdown -P now, halt -p, <u>init 0</u>

시스템 재부팅

- shutdown -r now, reboot, <u>init 6</u>

로그아웃

- logout, exit

자동 완성

- tab

도스 키

- 방향키 위아래를 누르면 이전에 입력한 명령어로 다시 나타낼 수 있다.

history

- 여태까지 사용한 명령어들의 이력

공유폴더를 설정하고 찾아보자

- VM-세팅-Option-Shared Folders 를 enable해준다.
- root@server:/# mount | grep hgfs
- vmhgfs-fuse on /mnt/hgfs type fuse.vmhgfs-fuse (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)
- 경로내에 지정해준 공유 폴더가 있다.

도움말(사용법) 명령어 man

- --help 옵션을 쓸 수도 있지만 man 명령어를 통해 확인할 수도 있다.
- ex) man vi
- 모든 명령어가 man을 지원하는것은 아니다.

## 마운트와 CD/DVD 및 USB의 활용★

- 마운트 - 물리적인 장치를 특정한 위치(대개는 디렉터리)에 연결시켜 주는 과정

- mount 명령어로 현재 마운트된 장치들을 확인할 수 있다.

- umount 명령어를 입력해서 마운트를 해제할 수 있다.

- umount /dev/cdrom 으로 cdrom이 언마운트된다.

- cdrom 세팅을 다시 설정해주고 connect해주면 다시 마운트된다.

- 현재의 작업중인 디렉터리 위치가 cdrom 내부이면 umount명령어가 먹히지 않는다. 

- USB를 연결하고 VMware 아래 작업표시줄에서 USB를 connect 해준다.

- mount 명령어를 실행해서 USB의 경로를 확인해본다.

- 언마운트 명령어를 실행해서 USB를 언마운트 하면 탐색기창에 USB가 없어진다.    umount /dev/sdg1

- DVD/USB 마운트를 완전히 해제하려면 다시 VMware 아래 작업표시줄에서 disconnect 해준다.

- 혹시라도 USB가 마운트 되지 않는다면 USB가 꽃힌 PC의 포트 버전과

  VMware의 USB 버전이 일치하는지 확인해준다.

- 텍스트모드의 서버에서도 진행을 해보자(p.169~)

- 일단 우분투서버에서는 마운트할 경로를 생성해주어야 한다.

  1. cdrom을 만들어보자

     - 처음엔 mount를 해보아도 cdrom이 확인되지 않는다.

     - mkdir /media/cdrom 으로 경로를 생성해준다.

     - VMware 설정에서 cdrom 에 이미지 파일을 넣어주고 connect 해준다.

     - cdrom의 기본 경로인 /dev/cdrom을 생성한 경로 /media/cdrom으로 마운트해준다.

       mount /dev/cdrom /media/cdrom

     - /media/cdrom에 우분투 이미지파일이 마운트된 것을 볼 수 있다.

     - 언마운트를 하면 경로안에 마운트된 내용이 다 없어진다.

       umount /media/cdrom

       umount /dev/cdrom

  2. usb를 만들어보자

     - 처음엔 mount를 해도 usb가 확인되지 않는다.

     - mkdir /media/usb 로 경로를 생성

     - VMware 설정에서 usb를 connect해준다.

     - usb의 기본 경로인 /dev/usb를 생성한 경로 /media/usb로 마운트해준다.

       mount /dev/sdb1 /media/usb

     - /media/usb에 usb안의 파일들이 마운트된 것을 볼 수 있다.

     - 언마운트를 하면 경로안에 마운트된 내용이 다 없어진다.

       umount /media/usb

       umount /dev/sdb1

  3. iso 파일을 직접 생성하고 마운트해보자

     - 먼저 genisoimage라는 프로그램을 설치해주어야 한다.

     - 설치되어있는지 확인해보자.

       dpkg --get-selections genisoimage

     - 설치가 되어있지 않은 경우 직접 설치해준다.

       apt-get install -y genisoimage

     - 이제 genisoimage 프로그램을 이용하여 iso파일을 만들고 마운트할 경로를 만들어보자.

       genisoimage -r -J -o boot.iso(생성할 ISO파일 이름) /boot(포함될 파일 또는 디렉터리)

       mkdir /media/iso

     - ls -l 로 생성된 iso파일을 확인해본다.

     - 생성된 iso 파일을 마운트해주고 파일 내용을 비교해본다.

       mount -o loop boot.iso /media/iso

       ll /media/iso

       ll /boot

     - 언마운트를 하면 경로안에 있던 내용들이 다 없어지는 것이다.

       umount /media/iso

       or     umount /root/boot.iso

     - 터미널에서는 x-윈도우처럼 자동으로 마운트되는 플러그 앤 플레이 기능을 지원하지 않기 때문에 전원이 꺼지면 마운트되었던 파일들이 언마운트된 상태로 유지가 된다. 그러므로 재부팅을 해도 마운트가 되지 않고 언마운트 된 채로 유지가 된다. 

- 기본 명령어

  - ls
    - Windows의 dir같은 역할, 해당 디렉터리의 파일목록 나열
  
      ex)   # ls /etc/systemd
  
  - cd
    
  - 디렉터리를 이동
    
    ex)   # cd ../etc/systemd
    
  - 절대경로와 상대경로를 이해하자
    
    현재 경로가 /etc 일 경우
    
    cd /data 의 결과는 root@server:/data/#
    
    cd ./data 의 결과는 root@server:/etc/data#
    
  - pwd
    
  - 현재 디렉터리의 전체 경로를 출력
    
  - rm
    
  - 파일이나 디렉터리를 삭제
    
    ex)   # rm -rf abc
    
  - cp
    - 파일이나 디렉터리를 복사
  
        해당 파일의 읽기권한이 필요
  
        ex)   # cp abc.txt cba.txt
  
  - touch
    - 크기가 0인 새 파일을 생성, 이미 존재하는 경우 수정 시간을 변경
  
      ex)   # touch abc.txt
  
  - mv
    - 파일과 디렉터리의 이름을 변경, 위치 이동시 사용
  
      ex)   # mv abc.txt www.txt
  
      \# mv aaa bbb ccc ddd		aaa,bbb,ccc 파일을 /ddd 디렉터리로 이동
  
  - mkdir
    - 새로운 디렉터리를 생성
  
      ex)   # mkdir abc   \# mkdir -p abc/xxx/yyy/zzz (부모 디렉터리가 없을경우 자동 생성) 	abc/xxx/yyy가 없을 경우 자동으로 생성해준다.
  
  - rmdir
    - 디렉터리를 삭제
  
      삭제 권한이 있어야 하며, 디렉터리는 비어 있어야 함.
  
      들어있는 경우 rm -r 을 사용
  
  - cat
    - 여러개 파일을 나열하면 파일을 연결해서 보여준다.
  
      ex)   # cat a.txt b.txt
  
  - head, tail
    - 텍스트 형식으로 작성된 파일의 앞 10행 또는 마지막 10해만 화면에 출력
  
      ex)   # head /etc/systemd/bootchart.conf
  
      \# head -3 /etc/systemd/bootchart.conf → 앞 3행만 화면에 출력
  
      \# tail -5 /etc/systemd/bootchart.conf → 마지막 5행만 화면에 출력
  
  - more
    - 텍스트 형식으로 작성된 파일을 페이지 단위로 화면에 출력
  
    - 다음 페이지 Space bar      앞 페이지 B      종료 Q
  
      ex)   # more +10 /etc/systemd/system.conf → 10행부터 출력
  
  - less
    - more과 비슷하지만 더 확장됨. more에서 사용하는 키도 사용가능, 
  
      Page Up, Page Down 사용 가능
  
      ex)   # less +10 /etc/systemd/system.conf → 10행부터 출력
  
  - file
    - 해당 파일이 어떤 종류의 파일인지 표시
  
      ex)   # file /etc/systemd/system.conf → 텍스트 파일이므로 ASCII로 표시됨
  
  - clear
  
    - 현재 사용 중 터미널 화면을 깨끗하게 지워줌
  
  - \>
    - redirect 명령어로 앞쪽에 있는 파일의 내용이나 명령어의 결과를 오른쪽에 생성한 파일에 집어넣는다.
  
      ex)   # cat aaa bbb > all

# 런 레벨 ★

p.144

ln 명령어

- 링크를 거는 명령어
- run level에서 사용해서 default.target을 여러 run level로 바꿔본다.



# 사용자와 그룹(p.179)

## 사용자 그룹

- 리눅스는 다중 사용자 시스템(Multi-User System)
- root : 기본제공계정으로 모든 작업 권한을 가진 수퍼유저
- 모든 사용자는 하나 이상의 그룹에 소속
- 계정 정보는 /etc/passwd 파일에 정의
  - 사용자 이름 : 암호 : 사용자 ID : 사용자가 소속된 주 그룹 ID : 추가 정보 : 홈 디렉터리 : 기본 쉘
- /etc/passwd 파일에 패스워드가 x로 표시된 경우 /etc/shadow 파일에 암호화되어 저장되어 있는것
- 그룹 정보는 /etc/group 파일에 정의
  - 그룹 이름 : 비밀번호 : 그룹 id : 보조 그룹 사용자

- 관련 명령어
  - adduser
    - 사용자 추가
    - 사용자 생성시 별도의 그룹을 지정하지 않으면, 자동으로 사용자 이름과 동일한 그룹이 생성되고 자동으로 포함된다.
  - passwd
    - 사용자 비밀번호 지정, 변경
  - usermod
    - 사용자 속성 변경
  - userdel
    - 사용자 삭제
    - -r : recursive -f : force
  - chage
    - 암호를 주기적으로 변경하도록 설정
  - groups
    - 사용자나 명령어의 대상이 소속된 그룹을 보여줌
  - groupadd
    - 새로운 그룹을 생성
  - groupmod
    - 그룹의 속성을 변경
  - groupdel
    - 그룹을 삭제
  - gpasswd
    - 그룹의 암호를 설정, 그룹 관리를 수행
- /etc/skel 디렉터리에 파일을 넣어놓으면 새로운 사용자가 생성될 때 홈 디렉터리에 복사하는 작업이 발생한다.

## 파일과 디렉터리의 소유와 허가권

- 리눅스는 각각의 파일과 디렉터림다 소유권과 허가권이라는 속성이 있다.

| 파일 유형 | 파일 허가권 | 링크 수 | 파일 소유자 이름 | 파일 소유그룹 이름 | 파일 크기(Byte) | 마지막 변경 날짜/시간 | 파일 이름  |
| --------- | ----------- | ------- | ---------------- | ------------------ | --------------- | --------------------- | ---------- |
| -         | rw-r--r--   | 1       | root             | root               | 0               | 7월 15 16:11          | sample.txt |

- 파일 유형

  - 디렉터리 : d
  - 일반 파일 : -
  - 블록 디바이스 : b     문자 디바이스 : c     링크 : l

- chmod 명령

  - 파일 허가권 변경 명령어

- 파일 소유권(Ownership)

  - 파일을 소유한 사용자와 그룹

- chown/chgrp 명령

  - 파일의 소유권을 바꾸는 명령어

  - ex) # chown ubuntu.ubuntu sample.txt

    \# chown ubuntu sample.txt

    \# chgrp ubuntu sample.txt

  - : 과 . 둘다 사용 가능

  - 사용자만 지정해주면 그 사용자와 맞는 그룹으로 자동 지정해준다.

- 링크

  ![](https://t1.daumcdn.net/cfile/tistory/2374E137516D185813)

  - 하드 링크(hard link)
    - 하드 링크 파일만 하나 생성되며 같은 inode1 사용
    - 명령 : # ln 링크대상파일이름 링크파일이름
  - 심볼릭 링크(symbolic link, soft link)
    - 새로운 inode2를 만들고, 데이터는 원본 파일을 연결하는 효과
    - 명령 : # ln -s 링크대상파일이름 링크파일이름
  - inode : 한 파일이나 디렉토리의 모든 정보를 갖고 있는 64byte로 구성된 표

![](./image/2.JPG)

## 리눅스 관리자를 위한 명령어(p.198)

dpkg(Debian Package)

- Windows의 setup.exe.와 비슷한 설치 파일
- 확장명은 *.deb, 이를 패키지라 부름

- deb 파일 형식 (패키지 파일 형식)

  - 패키지이름\_버전-개정번호_아키텍처.deb

- 명령어 옵션

  - 설치

    dpkg -i 패키지파일이름.deb

  - 삭제

    dpkg -r 패키지이름

    dpkg -P 패키지이름 - 설정파일까지 삭제

  - 패키지 조회

    **dpkg -l 패키지이름 - 설치된 패키지에 대한 정보를 조회**

    dpkg -L 패키지이름 - 패키지가 설치한 파일 목록을 보여줌

  - 아직 설치되지 않은 deb 파일 조회

    dpkg --info 패키지파일이름.deb

- 단점

  - 의존성 문제
  - 의존성 문제 해결을 위해 apt-get이 등장
  - 요즘은 이렇게 직접 받지 않고 모듈형식으로 레퍼지토리에서 다 받아와서 설치한다.

apt-get(p.205)

- dpkg의 의존성 문제를 완전 해결

- 인터넷을 통해 필요한 파일을 저장소(Repository)에서 자동으로 모두 다운로드해서 설치하는 방식

- 기본 사용법

  - 기본 설치 : apt-get install 패키지이름

    주로 -y옵션 사용 = 모두 yes

  - 패키지 목록의 업데이트 : apt-get update

  - 삭제 : apt-get remove 패키지이름

    apt-get purge 패키지이름

    apt-get autoremove

  - 내려받은 파일 제거

    apt-get clean

    apt-get autoclean

- 작동 방식과 설정파일

파일 압축과 묶기

- 파일 압축

  관련 명령

  - xz
  - bzip2
  - gzip
  - zip/unzip

- 파일 묶기

  - 리눅스(유닉스)에서는 '파일 압축'과 '파일 묶기'는 원칙적으로 별개의 프로그램으로 수행
  - 파일 묶기의 명령어는 'tar', 묶인 파일의 확장명도 'tar'

  파일 묶기 명령(tar)

  - tar : 확장명 tar로 묶음 파일을 만들어 주거나 묶음을 풀어준다.
    - 동작 : c(묶기), x(풀기), t(경로확인)
    - 옵션 : f(파일), v(과정보이기), J(tar+xz), z(tar+gzip), j(tar+bzip2)
  - 사용 예
    - \# tar cvf my.tar /etc/systemd/ → 묶기
    - \# tar cvfJ my.tar.xz /etc/systemd/ → 묶기 + xz 압축
    - \# tar cvfz my.tar.gz /etc/systemd/ → 묶기 + gzip 압축
    - \# tar cvfj my.tar.bz2 /etc/systemd/ → 묶기 + bzip2 압축
    - \# tar xvf my.tar → tar 풀기

파일 위치 검색

- find [경로] [옵션] [조건] [action] : 기본 파일 찾기
  - [옵션] -name, -user(소유자), -newer(전,후), -perm(허가권), -size(크기)
  - [action] -print(디폴트), -exec(외부명령 실행)
    - \# find /etc -name "*.conf"
    - \# find /bin -size +10k -size -100k
    - \# find /home -name "*.swp" -exec rm {} \;

시스템 설정

- 다양한 환경 설정 (unity-control-center)
- 네트워크 설정 (nmtui)
- 방화벽 설정 (ufw, gufw)
- 서비스 설정(rcconf)

CRON과 AT

- **cron ★**

  - 주기적으로 반복되는 일을 자동적으로 실행될 수 있도록 설정

  - 관련된 데몬(서비스)은 "crond", 관련 파일은 "/etc/crontab"

  - /etc/crontab 형식 (끝이 tab인 파일은 대부분 테이블)

    

    - | 분   | 시   | 일   | 월   | 요일(0~7; 0,7=일요일) | 사용자 | 실행명령            |
      | ---- | ---- | ---- | ---- | --------------------- | ------ | ------------------- |
      | 00   | 05   | 1    | *    | *                     | root   | cp -r /home /backup |

      ex) 매달 1일 5시에 홈 디렉터리의 모든 내용을 백업 디렉터리에 저장하라

  - 실습

  - **#!/bin/sh** → 아래 내용을 쉘에서 실행하라

    **set $(date)** → date는 현재 시간을 가져오는 것 $와 괄호로 묶으면 명령어를 실행하라는 뜻 이렇게 쓰지

    않으면 명령어가 아닌 그냥 하나의 문자열로 인식한다. 

    set은 뒤의 내용을 파라미터화 하라 공백들로 변수들을 구분.

    궁금하면 $(date)를 실행해보고 $1 $2 $3 $4 $5를 echo 명령어로 확인해보자

    **fname="backup-$1$2$3tar.xz"** → 쉘에서 변수를 선언할 때 띄워쓰기를 하면 =가 명령어로 인식

    이 되기때문에 띄우면 안된다.

    **tar cfJ /backup/$fname /home**

- at

  - 일회성 작업을 예약
  - ex
    - 예약 : \# at <시간>
    - \# at 3:00am tomorrow → 내일 새벽 3시
    - \# at now + 1 hour → 현재 1시간 뒤에

UMASK

- 파일의 기본권한은 666
- 디렉터리의 기본권한은 777
- umask 값을 기본값에서 빼주어서 생성된 파일/디렉터리의 권한 설정

# 네트워크 관련 필수 개념

- TCP/IP
  - 컴퓨터끼리 네트워크 상 의사소통하는 프로토콜 중 가장 보편적인 프로토콜의 한 종류
- 호스트 이름(Hostname)과 도메인 이름(Domain name)
  - 호스트 이름은 각각 컴퓨터에 지정된 이름
  - 도메인 이름(또는 도메인 주소)는 hanbit.co.kr과 같은 형식
- IP 주소
  - 각 컴퓨터의 랜카드에 부여되는 중복되지 않는 유일한 주소
  - 4바이트로 이루어져 있음, 각 자리는 0~255
- 네트워크 주소
  - 같은 네트워크에 속해 있는 공통된 주소(ex. 192.168.111.0)
- 브로드캐스트 주소
  - 내부 네트워크의 모든 컴퓨터가 듣게 되는 주소
  - 현재 주소의 제일 끝자리를 255로 바꾼 주소
- 게이트웨이
  - 라우터 = 게이트웨이
  - 네트워크 간에 데이터를 전송하는 컴퓨터 또는 장비
  - VMware의 게이트웨이 주소는 192.168.111.2로 고정
- 넷마스크와 클래스
  - 넷마스크 : 네트워크의 규모를 결정
- DNS 서버 주소
  - URL을 해당 컴퓨터의 IP주소로 변환해 주는 서버
  - 설정 파일은 /etc/resolv.conf

- 리눅스에서의 네트워크 장치 이름
  - 우분투가 랜카드 이름으로 ens32 또는 ens33으로 할당
  - 명령 예
    - \# ifconfig/ifdown/ifup ens32 또는 ens33

- 네트워크 관련 명령어

  - nm-connection-editor
  - systemctl start/stop/restart/status networking
    - restart 명령으로 변경된 네트워크 설정을 적용할 수 있다.
  - ifconfig 장치이름
  - nslookup
  - ping IP 주소 또는 URL
  - service lightdm restart 서비스가 상단 탭에서 사라졌을 때 쓰는 명령어

- 네트워크 설정과 관련된 주요 파일

  - 네트워크 기본 정보가 설정된 파일
    - X 윈도 모드 : /etc/NetworkManager/system-connections/유선 연결 1
    - 텍스트 모드 : /etc/network/interfaces
  - /etc/resolv.conf
    - DNS서버의 정보와 호스트 이름이 들어 있는 파일. 임시 사용 파일이므로 네트워크가 재시작되면 다시 내용이 초기화됨. 영구적으로 DNS 서버 정보를 변경하려면 nm-connection-editor 명령이나 /etc/network/interfaces 파일은 편집해야함
    - 127.0.0.1은 자신을 의미하지만 이 파일에서는 자기 자신이 DNS 서버라는 의미가 아니라 /etc/NetworkManager/system-connections/유선 연결 1 파일에 설정된 DNS 서버를 사용한다는 의미
  - /etc/hosts
    - 현 컴퓨터의 호스트 이름과 FQDN이 들어있는 파일

- 파이프, 필터, 리디렉션

  - 파이프

    - 2개의 프로그램을 연결해주는 연결 통로

    - |를 사용

      \# ls -l /etc | less

  - 필터

    - 필요한 것만 걸러주는 명령어

    - grep, tail, ec, sort, awk, sed 등

      \# ps -ef | grep bash

  - 리디렉션

    - 표준 입출력의 방향을 바꿔줌.

    - 표준 입력은 키보드, 표준 출력은 모니터이지만 이를 파일로 처리하고 싶을 때 주로 사용

      \# ls -l > list.txt  →  ls -l의 결과를 list.txt에 저장

      \# ls -l >> list.txt →  list.txt가 이미 존재하면 이어서 쓴다.

      \# sort < list.txt  →  list.txt 파일을 정렬해서 화면에 출력한다.

      \# sort < list.txt > out.txt  →  list.txt 파일을 정렬해서 out.txt 파일에 쓴다.

- 프로세스, 데몬, 서비스

  - 프로세스

    - 하드디스크에 저장된 실행코드(=프로그램)가, 메모리에 로딩되어 활성화된 것

    - 포그라운드 프로세스(Foreground Process)

      - 실행하면 화면에 나타나서 사용자와 상호작용을 하는 프로세스(대부분의 응용프로그램)
      - 포그라운드 프로세스 실행중 ctl+z 하면 정지되고 bg를 입력하면 백그라운드로 실행된다.

    - 백그라운드 프로세스(Background Process)

      - 실행은 됐지만, 화면에는 나타나지 않고 뒤에서 실행되는 프로세스 (서비스나 데몬이라부름)
      - 백그라운드 프로세스 실행중 fg 작업번호 명령을 입력하면 다시 포그라운드 프로세스로 만들 수 있다.

    - 프로세스 번호

      - 프로세스에 할당된 고유 번호

    - 작업 번호

      - 백그라운드 프로세스의 순차 번호

    - 부모 프로세스와 자식 프로세스

      - 모든 프로세스는 부모 프로세스 하위에 종속되어서 실행
      - 부모 프로세스 종료 → 종속된 자식 프로세스도 모두 종료

    - 프로세스 관련 명령

      - ps

        현재 프로세스 상태 확인

        ps -ef | grep <프로세스 이름>

      - kill

        프로세스를 강제 종료 명령어

        kill -9 <프로세스 번호> → (9 옵션은)무조건 종료

      - pstree

        부모 프로세스와 자식 프로세스의 관계를 트리 형태로 보여 줌

- 서비스와 소켓

  - 서비스 = 데몬
    - 늘 가동되는 서버 프로세스
    - 시스템과 독자적으로 구동되어 제공하는 프로세스 (예: Web, DB, FTP 서버 등)
    - 실행 및 종료는 대개 "systemctl start/stop/restart 서비스이름" 명령을 사용
    - 서비스의 실행 스크립트 파일은 "/lib/systemd/system/" 디렉터리에 "서비스이름.service"라는 이름으로 확인 가능
    - 부팅과 동시에 서비스의 자동 실행 여부를 지정할 수 있는데, 터미널에서 "systemctl list-unit-files" 명령을 실행하면 현재 사용 여부(enable/disable)를 확인할 수 있다.
    - rcconf 명령으로 설정 가능
  - 소켓
    - 서비스는 항상 가동하지만 소켓은 외부에서 특정 서비스를 요청할 경우에  systemd가 구동시키고 요청이 끝나면 소켓도 종료
    - 그래서 소켓으로 설정된 서비스는 systemd가 서비스를 새로 구동하는데 시간이 소요되므로 처음 연결되는데 더 많은 시간이 걸림 (예: 텔넷 서버)
    - 소켓과 관련된 스크립트 파일은 "/lib/systemd/system/" 디렉터리에 "소켓이름.socket" 이름으로 존재

- 응급 복구(p.251)

  - 시스템이 부팅이 안 되는 경우는 다양하다.
  - 부팅중 esc 연타해 grub 메뉴화면으로

- GRUB 부트로더(p.254)