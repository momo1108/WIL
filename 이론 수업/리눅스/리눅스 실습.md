# 리눅스

Shell 은 os와 사용자간의 메세지를 전달

암호화된 패스워드가 /etc/passwd가 아닌 /etc/shadow에 저장되는 이유

다른 사용자가 passwd는 볼 수있지만 shadow는 볼 수 없다.

shadow파일의 내용 중 줄의 마지막 항목 쉘의 경우 /bin/bash는 원격 접속이 가능하지만 /bin/false는 원겹 접근을 막는 역할을 한다.

# 리눅스 실습

- 가상 콘솔
  - 우분투는 7개의 가상 콘솔 사용
  - Ctrl + Alt + F1~F7
  - Ctrl + Alt + F7 → X-Window Mode
- mount ⇐ VMware Tools CD의 마운팅 경로를 확인
-  cd /media/root/VMware\ Tools



- 리눅스에서는 띄워쓰기가 명령어와 서브명령어를 구분하는 역할을 한다.

- 따라서 cd명령어를 사용할 때 폴더 명에 띄워쓰기가 있으면 공백을 명령어가 아닌 폴더명의 일부로 인식하기 위해 \를 사용해서 escape를 해준다.



- cp *.gz /tmp ⇐ 설치 파일을 작업 디렉터리로 복사

- cd /tmp ⇐ 작업 디렉터리로 이동

- tar -xvf VMware[TABKEY]

- cd vmare[TABKEY]

- ./vmware-install.pl

- 첫번째 질문에 yes를 입력하고 나머지는 엔터(디폴트로 설치)

- 끝나고 나면 reboot



# vi 편집기

vi → 명령어 모드

![](https://cau-dosc.github.io/images/vi-mode-switching.PNG)

- 명령어 모드에서 i(현재커서부터 입력), a(커서다음부터 입력)를 입력하면 편집모드로 들어간다
- 편집모드에서 명령어 모드로 들어오려면 esc키를 누른다.
- 명령어 모드에서 라인명령모드로 들어가려면 : 을 입력한다. 역시 돌아오려면 esc를 누른다.
  - :q (종료) :w (저장) :wq (저장 후 종료) : q!(강제로 종료)
  - /ba ☞ ba로 시작하는 문자열을 찾는다. 다음 문자열 찾기 - n
  - vi편집기를 사용하여 편집하는 도중에 터미널이 종료되면 그 파일의 임시저장(swp)파일이 저장된다.
  - 임시저장 파일은 숨김파일이다. ls -a로 볼 수 있다. linux의 숨김파일은 이름 앞에 . 이 붙는다.



# 명령어 프롬프트

사용자@호스트 : 경로 $#

ex) root@Server-b:~#

명령어들(p.140)

종료하는 방법

- poweroff, shutdown -P now, halt -p, <u>init 0</u>

시스템 재부팅

- shutdown -r now, reboot, <u>init 6</u>

로그아웃

- logout, exit

자동 완성

- tab

도스 키

- 방향키 위아래를 누르면 이전에 입력한 명령어로 다시 나타낼 수 있다.

history

- 여태까지 사용한 명령어들의 이력

공유폴더를 설정하고 찾아보자

- VM-세팅-Option-Shared Folders 를 enable해준다.
- root@server:/# mount | grep hgfs
- vmhgfs-fuse on /mnt/hgfs type fuse.vmhgfs-fuse (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)
- 경로내에 지정해준 공유 폴더가 있다.

도움말(사용법) 명령어 man

- --help 옵션을 쓸 수도 있지만 man 명령어를 통해 확인할 수도 있다.
- ex) man vi
- 모든 명령어가 man을 지원하는것은 아니다.

## 마운트와 CD/DVD 및 USB의 활용★

- 마운트 - 물리적인 장치를 특정한 위치(대개는 디렉터리)에 연결시켜 주는 과정

- mount 명령어로 현재 마운트된 장치들을 확인할 수 있다.

- umount 명령어를 입력해서 마운트를 해제할 수 있다.

- umount /dev/cdrom 으로 cdrom이 언마운트된다.

- cdrom 세팅을 다시 설정해주고 connect해주면 다시 마운트된다.

- 현재의 작업중인 디렉터리 위치가 cdrom 내부이면 umount명령어가 먹히지 않는다. 

- USB를 연결하고 VMware 아래 작업표시줄에서 USB를 connect 해준다.

- mount 명령어를 실행해서 USB의 경로를 확인해본다.

- 언마운트 명령어를 실행해서 USB를 언마운트 하면 탐색기창에 USB가 없어진다.    umount /dev/sdg1

- DVD/USB 마운트를 완전히 해제하려면 다시 VMware 아래 작업표시줄에서 disconnect 해준다.

- 혹시라도 USB가 마운트 되지 않는다면 USB가 꽃힌 PC의 포트 버전과

  VMware의 USB 버전이 일치하는지 확인해준다.

- 텍스트모드의 서버에서도 진행을 해보자(p.169~)

- 일단 우분투서버에서는 마운트할 경로를 생성해주어야 한다.

  1. cdrom을 만들어보자

     - 처음엔 mount를 해보아도 cdrom이 확인되지 않는다.

     - mkdir /media/cdrom 으로 경로를 생성해준다.

     - VMware 설정에서 cdrom 에 이미지 파일을 넣어주고 connect 해준다.

     - cdrom의 기본 경로인 /dev/cdrom을 생성한 경로 /media/cdrom으로 마운트해준다.

       mount /dev/cdrom /media/cdrom

     - /media/cdrom에 우분투 이미지파일이 마운트된 것을 볼 수 있다.

     - 언마운트를 하면 경로안에 마운트된 내용이 다 없어진다.

       umount /media/cdrom

       umount /dev/cdrom

  2. usb를 만들어보자

     - 처음엔 mount를 해도 usb가 확인되지 않는다.

     - mkdir /media/usb 로 경로를 생성

     - VMware 설정에서 usb를 connect해준다.

     - usb의 기본 경로인 /dev/usb를 생성한 경로 /media/usb로 마운트해준다.

       mount /dev/sdb1 /media/usb

     - /media/usb에 usb안의 파일들이 마운트된 것을 볼 수 있다.

     - 언마운트를 하면 경로안에 마운트된 내용이 다 없어진다.

       umount /media/usb

       umount /dev/sdb1

  3. iso 파일을 직접 생성하고 마운트해보자

     - 먼저 genisoimage라는 프로그램을 설치해주어야 한다.

     - 설치되어있는지 확인해보자.

       dpkg --get-selections genisoimage

     - 설치가 되어있지 않은 경우 직접 설치해준다.

       apt-get install -y genisoimage

     - 이제 genisoimage 프로그램을 이용하여 iso파일을 만들고 마운트할 경로를 만들어보자.

       genisoimage -r -J -o boot.iso(생성할 ISO파일 이름) /boot(포함될 파일 또는 디렉터리)

       mkdir /media/iso

     - ls -l 로 생성된 iso파일을 확인해본다.

     - 생성된 iso 파일을 마운트해주고 파일 내용을 비교해본다.

       mount -o loop boot.iso /media/iso

       ll /media/iso

       ll /boot

     - 언마운트를 하면 경로안에 있던 내용들이 다 없어지는 것이다.

       umount /media/iso

       or     umount /root/boot.iso

     - 터미널에서는 x-윈도우처럼 자동으로 마운트되는 플러그 앤 플레이 기능을 지원하지 않기 때문에 전원이 꺼지면 마운트되었던 파일들이 언마운트된 상태로 유지가 된다. 그러므로 재부팅을 해도 마운트가 되지 않고 언마운트 된 채로 유지가 된다. 

- 기본 명령어

  - ls
    - Windows의 dir같은 역할, 해당 디렉터리의 파일목록 나열
  
      ex)   # ls /etc/systemd
  
  - cd
    
  - 디렉터리를 이동
    
    ex)   # cd ../etc/systemd
    
  - 절대경로와 상대경로를 이해하자
    
    현재 경로가 /etc 일 경우
    
    cd /data 의 결과는 root@server:/data/#
    
    cd ./data 의 결과는 root@server:/etc/data#
    
  - pwd
    
  - 현재 디렉터리의 전체 경로를 출력
    
  - rm
    
  - 파일이나 디렉터리를 삭제
    
    ex)   # rm -rf abc
    
  - cp
    - 파일이나 디렉터리를 복사
  
        해당 파일의 읽기권한이 필요
  
        ex)   # cp abc.txt cba.txt
  
  - touch
    - 크기가 0인 새 파일을 생성, 이미 존재하는 경우 수정 시간을 변경
  
      ex)   # touch abc.txt
  
  - mv
    - 파일과 디렉터리의 이름을 변경, 위치 이동시 사용
  
      ex)   # mv abc.txt www.txt
  
      \# mv aaa bbb ccc ddd		aaa,bbb,ccc 파일을 /ddd 디렉터리로 이동
  
  - mkdir
    - 새로운 디렉터리를 생성
  
      ex)   # mkdir abc   \# mkdir -p abc/xxx/yyy/zzz (부모 디렉터리가 없을경우 자동 생성) 	abc/xxx/yyy가 없을 경우 자동으로 생성해준다.
  
  - rmdir
    - 디렉터리를 삭제
  
      삭제 권한이 있어야 하며, 디렉터리는 비어 있어야 함.
  
      들어있는 경우 rm -r 을 사용
  
  - cat
    - 여러개 파일을 나열하면 파일을 연결해서 보여준다.
  
      ex)   # cat a.txt b.txt
  
  - head, tail
    - 텍스트 형식으로 작성된 파일의 앞 10행 또는 마지막 10해만 화면에 출력
  
      ex)   # head /etc/systemd/bootchart.conf
  
      \# head -3 /etc/systemd/bootchart.conf → 앞 3행만 화면에 출력
  
      \# tail -5 /etc/systemd/bootchart.conf → 마지막 5행만 화면에 출력
  
  - more
    - 텍스트 형식으로 작성된 파일을 페이지 단위로 화면에 출력
  
    - 다음 페이지 Space bar      앞 페이지 B      종료 Q
  
      ex)   # more +10 /etc/systemd/system.conf → 10행부터 출력
  
  - less
    - more과 비슷하지만 더 확장됨. more에서 사용하는 키도 사용가능, 
  
      Page Up, Page Down 사용 가능
  
      ex)   # less +10 /etc/systemd/system.conf → 10행부터 출력
  
  - file
    - 해당 파일이 어떤 종류의 파일인지 표시
  
      ex)   # file /etc/systemd/system.conf → 텍스트 파일이므로 ASCII로 표시됨
  
  - clear
  
    - 현재 사용 중 터미널 화면을 깨끗하게 지워줌
  
  - \>
    - redirect 명령어로 앞쪽에 있는 파일의 내용이나 명령어의 결과를 오른쪽에 생성한 파일에 집어넣는다.
  
      ex)   # cat aaa bbb > all

# 런 레벨 ★

p.144

시스템을 종료하는 init 0, 재부팅하는 init 6. init 명령어 뒤에 붙는 숫자를 런 레벨이라고 부른다. 리눅스는 시스템이 가동되는 방법을 7가지 런레벨로 나눌 수 있으며, 런 레벨은 다음과 같다.

| 런레벨 | 영문 모드  | 설명                           | 비고             |
| ------ | ---------- | ------------------------------ | ---------------- |
| 0      | Power Off  | 종료 모드                      |                  |
| 1      | Rescue     | 시스템 복구 모드               | 단일 사용자 모드 |
| 2      | Multi-User |                                | 사용하지 않음    |
| 3      | Multi-User | 텍스트 모드의 다중 사용자 모드 |                  |
| 4      | Multi-User |                                | 사용하지 않음    |
| 5      | Graphical  | 그래픽 모드의 다중 사용자 모드 |                  |
| 6      | Reboot     |                                |                  |

init 0 명령은 지금 즉시 런 레벨 0번으로 시스템을 전환하라는 의미이며, 런 레벨 0번은 '종료 모드'이므로 결국 지금 즉시 시스템을 종료하라는 의미다.

- ls -l /lib/systemd/system/default.target → default.target에 연결된 파일을 확인(시스템에 기본으로 설정된 런 레벨이 지정되어 있음).

ln 명령어

- 링크를 거는 명령어

- ln -sf /lib/systemd/system/multi-user.target /lib/systemd/system/default.target

  → default.target이 가리키는 파일을 텍스트 모드로 부팅되는 런 레벨 3번인 multi-user.target으로 변경

- run level에서 사용해서 default.target을 여러 run level로 바꿔본다.



# 사용자와 그룹(p.179)

## 사용자 그룹

- 리눅스는 다중 사용자 시스템(Multi-User System)
- root : 기본제공계정으로 모든 작업 권한을 가진 수퍼유저
- 모든 사용자는 하나 이상의 그룹에 소속
- 계정 정보는 /etc/passwd 파일에 정의
  - 사용자 이름 : 암호 : 사용자 ID : 사용자가 소속된 주 그룹 ID : 추가 정보 : 홈 디렉터리 : 기본 쉘
- /etc/passwd 파일에 패스워드가 x로 표시된 경우 /etc/shadow 파일에 암호화되어 저장되어 있는것
- 그룹 정보는 /etc/group 파일에 정의
  - 그룹 이름 : 비밀번호 : 그룹 id : 보조 그룹 사용자

- 관련 명령어
  - adduser
    - 사용자 추가
    - 사용자 생성시 별도의 그룹을 지정하지 않으면, 자동으로 사용자 이름과 동일한 그룹이 생성되고 자동으로 포함된다.
  - passwd
    - 사용자 비밀번호 지정, 변경
  - usermod
    - 사용자 속성 변경
  - userdel
    - 사용자 삭제
    - -r : recursive -f : force
  - chage
    - 암호를 주기적으로 변경하도록 설정
  - groups
    - 사용자나 명령어의 대상이 소속된 그룹을 보여줌
  - groupadd
    - 새로운 그룹을 생성
  - groupmod
    - 그룹의 속성을 변경
  - groupdel
    - 그룹을 삭제
  - gpasswd
    - 그룹의 암호를 설정, 그룹 관리를 수행
- /etc/skel 디렉터리에 파일을 넣어놓으면 새로운 사용자가 생성될 때 홈 디렉터리에 복사하는 작업이 발생한다.

## 파일과 디렉터리의 소유와 허가권

- 리눅스는 각각의 파일과 디렉터림다 소유권과 허가권이라는 속성이 있다.

| 파일 유형 | 파일 허가권 | 링크 수 | 파일 소유자 이름 | 파일 소유그룹 이름 | 파일 크기(Byte) | 마지막 변경 날짜/시간 | 파일 이름  |
| --------- | ----------- | ------- | ---------------- | ------------------ | --------------- | --------------------- | ---------- |
| -         | rw-r--r--   | 1       | root             | root               | 0               | 7월 15 16:11          | sample.txt |

- 파일 유형

  - 디렉터리 : d
  - 일반 파일 : -
  - 블록 디바이스 : b     문자 디바이스 : c     링크 : l

- chmod 명령

  - 파일 허가권 변경 명령어
  - chmod (u(소유자)/g(그룹)/o(다른사람들)/a(모두=ugo))(+/-/=)(r/w/x) 파일/폴더명 = 권한 변경
  - chmod (2진수 세자리 3개) 파일/폴더명 = 권한 변경

- 파일 소유권(Ownership)

  - 파일을 소유한 사용자와 그룹

- chown/chgrp 명령

  - 파일의 소유권을 바꾸는 명령어

  - ex) # chown ubuntu.ubuntu sample.txt

    \# chown ubuntu sample.txt

    \# chgrp ubuntu sample.txt

  - chown (사용자):(그룹) 파일/폴더명 = 소유 변경

  - : 과 . 둘다 사용 가능

  - 사용자만 지정해주면 그 사용자와 맞는 그룹으로 자동 지정해준다.

- 링크

  ![](https://t1.daumcdn.net/cfile/tistory/2374E137516D185813)

  - 하드 링크(hard link)
    - 하드 링크 파일만 하나 생성되며 같은 inode1 사용
    - 명령 : # ln 링크대상파일이름 링크파일이름
  - 심볼릭 링크(symbolic link, soft link)
    - 새로운 inode2를 만들고, 데이터는 원본 파일을 연결하는 효과
    - 명령 : # ln -s 링크대상파일이름 링크파일이름
  - inode : 한 파일이나 디렉토리의 모든 정보를 갖고 있는 64byte로 구성된 표

![](./image/2.JPG)

## 리눅스 관리자를 위한 명령어(p.198)

dpkg(Debian Package)

- Windows의 setup.exe.와 비슷한 설치 파일
- 확장명은 *.deb, 이를 패키지라 부름

- deb 파일 형식 (패키지 파일 형식)

  - 패키지이름\_버전-개정번호_아키텍처.deb

- 명령어 옵션

  - 설치

    dpkg -i 패키지파일이름.deb

  - 삭제

    dpkg -r 패키지이름

    dpkg -P 패키지이름 - 설정파일까지 삭제

  - 패키지 조회

    **dpkg -l 패키지이름 - 설치된 패키지에 대한 정보를 조회**

    dpkg -L 패키지이름 - 패키지가 설치한 파일 목록을 보여줌

  - 아직 설치되지 않은 deb 파일 조회

    dpkg --info 패키지파일이름.deb

- 단점

  - 의존성 문제
  - 의존성 문제 해결을 위해 apt-get이 등장
  - 요즘은 이렇게 직접 받지 않고 모듈형식으로 레퍼지토리에서 다 받아와서 설치한다.

apt-get(p.205)

- dpkg의 의존성 문제를 완전 해결

- 인터넷을 통해 필요한 파일을 저장소(Repository)에서 자동으로 모두 다운로드해서 설치하는 방식

- 기본 사용법

  - 기본 설치 : apt-get install 패키지이름

    주로 -y옵션 사용 = 모두 yes

  - 패키지 목록의 업데이트 : apt-get update

  - 삭제 : apt-get remove 패키지이름

    apt-get purge 패키지이름

    apt-get autoremove

  - 내려받은 파일 제거

    apt-get clean

    apt-get autoclean

- 작동 방식과 설정파일

파일 압축과 묶기

- 파일 압축

  관련 명령

  - xz
  - bzip2
  - gzip
  - zip/unzip

- 파일 묶기

  - 리눅스(유닉스)에서는 '파일 압축'과 '파일 묶기'는 원칙적으로 별개의 프로그램으로 수행
  - 파일 묶기의 명령어는 'tar', 묶인 파일의 확장명도 'tar'

  파일 묶기 명령(tar)

  - tar : 확장명 tar로 묶음 파일을 만들어 주거나 묶음을 풀어준다.
    - 동작 : c(묶기), x(풀기), t(경로확인)
    - 옵션 : f(파일), v(과정보이기), J(tar+xz), z(tar+gzip), j(tar+bzip2)
  - 사용 예
    - \# tar cvf my.tar /etc/systemd/ → 묶기
    - \# tar cvfJ my.tar.xz /etc/systemd/ → 묶기 + xz 압축
    - \# tar cvfz my.tar.gz /etc/systemd/ → 묶기 + gzip 압축
    - \# tar cvfj my.tar.bz2 /etc/systemd/ → 묶기 + bzip2 압축
    - \# tar xvf my.tar → tar 풀기

파일 위치 검색

- find [경로] [옵션] [조건] [action] : 기본 파일 찾기
  - [옵션] -name, -user(소유자), -newer(전,후), -perm(허가권), -size(크기)
  - [action] -print(디폴트), -exec(외부명령 실행)
    - \# find /etc -name "*.conf"
    - \# find /bin -size +10k -size -100k
    - \# find /home -name "*.swp" -exec rm {} \;

시스템 설정

- 다양한 환경 설정 (unity-control-center)
- 네트워크 설정 (nmtui)
- 방화벽 설정 (ufw, gufw)
- 서비스 설정(rcconf)

## CRON과 AT(p.224) ★

- **cron ★**

  - 주기적으로 반복되는 일을 자동적으로 실행될 수 있도록 설정

  - 관련된 데몬(서비스)은 "crond", 관련 파일은 "/etc/crontab"

  - /etc/crontab 형식 (끝이 tab인 파일은 대부분 테이블)

    

    - | 분   | 시   | 일   | 월   | 요일(0~7; 0,7=일요일) | 사용자 | 실행명령            |
      | ---- | ---- | ---- | ---- | --------------------- | ------ | ------------------- |
      | 00   | 05   | 1    | *    | *                     | root   | cp -r /home /backup |

      ex) 매달 1일 5시에 홈 디렉터리의 모든 내용을 백업 디렉터리에 저장하라

  - 실습

  - **#!/bin/sh** → 아래 내용을 쉘에서 실행하라

    **set $(date)** → date는 현재 시간을 가져오는 것 $와 괄호로 묶으면 명령어를 실행하라는 뜻 이렇게 쓰지

    않으면 명령어가 아닌 그냥 하나의 문자열로 인식한다. 

    set은 뒤의 내용을 파라미터화 하라 공백들로 변수들을 구분.

    궁금하면 $(date)를 실행해보고 $1 $2 $3 $4 $5를 echo 명령어로 확인해보자

    **fname="backup-$1$2$3tar.xz"** → 쉘에서 변수를 선언할 때 띄워쓰기를 하면 =가 명령어로 인식

    이 되기때문에 띄우면 안된다.

    **tar cfJ /backup/$fname /home**

- at

  - 일회성 작업을 예약
  - ex
    - 예약 : \# at <시간>
    - \# at 3:00am tomorrow → 내일 새벽 3시
    - \# at now + 1 hour → 현재 1시간 뒤에

UMASK

- 파일의 기본권한은 666
- 디렉터리의 기본권한은 777
- umask 값을 기본값에서 빼주어서 생성된 파일/디렉터리의 권한 설정

# 네트워크 관련 필수 개념

- TCP/IP
  
  - 컴퓨터끼리 네트워크 상 의사소통하는 프로토콜 중 가장 보편적인 프로토콜의 한 종류
- 호스트 이름(Hostname)과 도메인 이름(Domain name)
  - 호스트 이름은 각각 컴퓨터에 지정된 이름
  - 도메인 이름(또는 도메인 주소)는 hanbit.co.kr과 같은 형식
- IP 주소
  - 각 컴퓨터의 랜카드에 부여되는 중복되지 않는 유일한 주소
  - 4바이트로 이루어져 있음, 각 자리는 0~255
- 네트워크 주소
  
  - 같은 네트워크에 속해 있는 공통된 주소(ex. 192.168.111.0)
- 브로드캐스트 주소
  - 내부 네트워크의 모든 컴퓨터가 듣게 되는 주소
  - 현재 주소의 제일 끝자리를 255로 바꾼 주소
- 게이트웨이
  - 라우터 = 게이트웨이
  - 네트워크 간에 데이터를 전송하는 컴퓨터 또는 장비
  - VMware의 게이트웨이 주소는 192.168.111.2로 고정
- 넷마스크와 클래스
  
  - 넷마스크 : 네트워크의 규모를 결정
- DNS 서버 주소
  - URL을 해당 컴퓨터의 IP주소로 변환해 주는 서버
  - 설정 파일은 /etc/resolv.conf

- 리눅스에서의 네트워크 장치 이름
  - 우분투가 랜카드 이름으로 ens32 또는 ens33으로 할당
  - 명령 예
    - \# ifconfig/ifdown/ifup ens32 또는 ens33

- 네트워크 관련 명령어

  - nm-connection-editor
  - systemctl start/stop/restart/status networking
    - restart 명령으로 변경된 네트워크 설정을 적용할 수 있다.
  - ifconfig 장치이름
  - nslookup
  - ping IP 주소 또는 URL
  - service lightdm restart 서비스가 상단 탭에서 사라졌을 때 쓰는 명령어

- 네트워크 설정과 관련된 주요 파일

  - 네트워크 기본 정보가 설정된 파일
    - X 윈도 모드 : /etc/NetworkManager/system-connections/유선 연결 1
    - 텍스트 모드 : /etc/network/interfaces
  - /etc/resolv.conf
    - DNS서버의 정보와 호스트 이름이 들어 있는 파일. 임시 사용 파일이므로 네트워크가 재시작되면 다시 내용이 초기화됨. 영구적으로 DNS 서버 정보를 변경하려면 nm-connection-editor 명령이나 /etc/network/interfaces 파일은 편집해야함
    - 127.0.0.1은 자신을 의미하지만 이 파일에서는 자기 자신이 DNS 서버라는 의미가 아니라 /etc/NetworkManager/system-connections/유선 연결 1 파일에 설정된 DNS 서버를 사용한다는 의미
  - /etc/hosts
    - 현 컴퓨터의 호스트 이름과 FQDN이 들어있는 파일

- 파이프, 필터, 리디렉션

  - 파이프

    - 2개의 프로그램을 연결해주는 연결 통로

    - |를 사용

      \# ls -l /etc | less

  - 필터

    - 필요한 것만 걸러주는 명령어

    - grep, tail, ec, sort, awk, sed 등

      \# ps -ef | grep bash

  - 리디렉션

    - 표준 입출력의 방향을 바꿔줌.

    - 표준 입력은 키보드, 표준 출력은 모니터이지만 이를 파일로 처리하고 싶을 때 주로 사용

      \# ls -l > list.txt  →  ls -l의 결과를 list.txt에 저장

      \# ls -l >> list.txt →  list.txt가 이미 존재하면 이어서 쓴다.

      \# sort < list.txt  →  list.txt 파일을 정렬해서 화면에 출력한다.

      \# sort < list.txt > out.txt  →  list.txt 파일을 정렬해서 out.txt 파일에 쓴다.

- 프로세스, 데몬, 서비스

  - 프로세스

    - 하드디스크에 저장된 실행코드(=프로그램)가, 메모리에 로딩되어 활성화된 것

    - 포그라운드 프로세스(Foreground Process)

      - 실행하면 화면에 나타나서 사용자와 상호작용을 하는 프로세스(대부분의 응용프로그램)
      - 포그라운드 프로세스 실행중 ctl+z 하면 정지되고 bg를 입력하면 백그라운드로 실행된다.

    - 백그라운드 프로세스(Background Process)

      - 실행은 됐지만, 화면에는 나타나지 않고 뒤에서 실행되는 프로세스 (서비스나 데몬이라부름)
      - 백그라운드 프로세스 실행중 fg 작업번호 명령을 입력하면 다시 포그라운드 프로세스로 만들 수 있다.

    - 프로세스 번호

      - 프로세스에 할당된 고유 번호

    - 작업 번호

      - 백그라운드 프로세스의 순차 번호

    - 부모 프로세스와 자식 프로세스

      - 모든 프로세스는 부모 프로세스 하위에 종속되어서 실행
      - 부모 프로세스 종료 → 종속된 자식 프로세스도 모두 종료

    - 프로세스 관련 명령

      - ps

        현재 프로세스 상태 확인

        ps -ef | grep <프로세스 이름>

      - kill

        프로세스를 강제 종료 명령어

        kill -9 <프로세스 번호> → (9 옵션은)무조건 종료

      - pstree

        부모 프로세스와 자식 프로세스의 관계를 트리 형태로 보여 줌

- 서비스와 소켓

  - 서비스 = 데몬
    - 늘 가동되는 서버 프로세스
    - 시스템과 독자적으로 구동되어 제공하는 프로세스 (예: Web, DB, FTP 서버 등)
    - 실행 및 종료는 대개 "systemctl start/stop/restart 서비스이름" 명령을 사용
    - 서비스의 실행 스크립트 파일은 "/lib/systemd/system/" 디렉터리에 "서비스이름.service"라는 이름으로 확인 가능
    - 부팅과 동시에 서비스의 자동 실행 여부를 지정할 수 있는데, 터미널에서 "systemctl list-unit-files" 명령을 실행하면 현재 사용 여부(enable/disable)를 확인할 수 있다.
    - rcconf 명령으로 설정 가능
  - 소켓
    - 서비스는 항상 가동하지만 소켓은 외부에서 특정 서비스를 요청할 경우에  systemd가 구동시키고 요청이 끝나면 소켓도 종료
    - 그래서 소켓으로 설정된 서비스는 systemd가 서비스를 새로 구동하는데 시간이 소요되므로 처음 연결되는데 더 많은 시간이 걸림 (예: 텔넷 서버)
    - 소켓과 관련된 스크립트 파일은 "/lib/systemd/system/" 디렉터리에 "소켓이름.socket" 이름으로 존재

- 응급 복구(p.251)

  - 시스템이 부팅이 안 되는 경우는 다양하다.
  - 부팅중 esc 연타해 grub 메뉴화면으로

- GRUB 부트로더(p.254)

# 하드디스크 관리와 사용자별 공간 할당

## SATA 장치와 SCSI 장치 구성(p.323)

- 하드디스크를 물리적으로는 /dev/sda, /dev/sdb, /dev/sdc ... 형식으로 부르면 되고, 그 장치에 파티션이 나눠진 것을 논리적으로는 /dev/sda1, /dev/sda2, /dev/sdb1, /dev/sdb2 ... 형식으로 부르면 된다.
- 파티션을 그냥 사용할 수 없으며 반드시 특정한 디렉터리에 마운트 시켜야만 사용이 가능

**실습. 하드디스크 1개 장착**

- 목표

  - 하드디스크 추가 장착해서 사용
  - 디스크 파티셔닝과 관련된 fdisk, mkfs, mount 명령을 익힌다.
  - 부팅시 자동으로 읽히는 /etc/fstab 파일을 편집한다.

- 과정

  - VM 세팅

    ADD - HDD - SCSI - Create a new virtual disk - 1GB(store disk as a single file) - 이름 설정 - OK

  - 파티션 설정

    **fdisk /dev/sdb**

    Command : n → 새로운 파티션 분할

    Select : p → Primary 파티션 선택

    Partition number : 1 → 파티션 번호 1번 선택(Primary 파티션은 최대 4개까지 생성 가능)

    First sector : Enter → 시작 섹터 번호 입력(1개의 파티션만 계획 중이므로 첫 섹터(default값 : 2048)로 설정)

    Last sector : Enter → 마지막 섹터 번호 입력(1개의 파티션만 계획 중이므로 마지막 섹터로 설정)

    Command : p → 설정된 내용 확인

    Command : w → 설정 저장

    ※ 리눅스에서 섹터 하나는 512바이트로 설정되어 있다. 그러므로 512 * 2097152 = 1,024MB(=1GB)가 된다. 이는 VMware의 가상 하드디스크에 적용되는 크기일 뿐, 실제 하드디스크라면 상황이 다를 수도 있다. 긜고 시작 섹터가 2048번인 이유는 **제일 앞의 0~2047(=1MB) 부분은 시스템 성능 향상을 위해 사용하지 않는 부분이기 때문**이다. 또 Blocks의 단위는 1KB(=1024바이트)로 설정되어 있다.

  - mkfs로 파일시스템을 설정

    **mkfs -t 파일시스템 파티션장치** or

    **mkfs.파일시스템 파티션장치**

    mkfs.ext4 /dev/sdb1

  - 마운트를 해야함

    mkdir /mydata → 마운트 할 디렉터리 생성

    gedit /mydata/test1 → 마운트 하기 전 시점의 파일을 생성

    mount /dev/sdb1 /mydata → /mydata에 새로운 하드디스크 파티션을 마운트

    ls -l /mydata → test1 파일이 사라진 것을 볼 수 있다.

    gedit /mydata/test2 → 마운트 하고 난 후 시점의 파일을 생성

    umount /dev/sdb1 → 언마운트를 해줌

    ls -l /mydata → test2 파일이 사라지고 test1 파일이 다시 나타난 것을 확인할 수 있다.

    

RAID 정의 및 개념

- RAID(Redundant Array of Inexpensive Disks)

  - 여러 개의 디스크를 하나의 디스크처럼 사용하는 방식
  - 비용 절감 + 신뢰성 향상 + 성능 향상

- 하드웨어 RAID

  - 하드웨어 제조업체

- 소프트웨어 RAID

  - 

- 각 RAID 방식의 비교

  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F274AB8385961D68428CF3A)

  - Linear RAID

    - 최소 2개의 하드디스크가 필요
    - 2개 이상의 하드디스크를 1개의 볼륨으로 사용
    - 앞 디스크부터 차례로 저장
    - 100%의 공간효율성(= 비용 저렴)

    ![](https://2.bp.blogspot.com/-9inhAmYQ10M/Wq5T3efswII/AAAAAAAABnY/QOg_JZq-N3MQTo-hKxbFYewGnNoNef0_gCLcBGAs/s1600/RAID%2BLinear.png)

  - RAID0 = Stripping

    - 최소 2개의 하드디스크가 필요
    - 모든 디스크에 동시에 저장
    - 100%의 공간효율성 (= 비용 저렴)
    - 신뢰성 낮음
    - "빠른 성능을 요구하되, 혹시 전부 잃어버려도 큰 문제가 되지 않는 자료"에 적합

    ![](https://1.bp.blogspot.com/-ExZh8Guvw8w/Wq5T8LMpa5I/AAAAAAAABnc/uYBNqcY34vUJB5FLTao5CAo4nScWKicXQCLcBGAs/s320/RAID%2B0.png)

  - RAID1 = Mirroring

    - 데이터 저장에 두배의 용량이 필요
    - 결함 허용(Fault-tolerance)을 제공 = 신뢰성 높음ㅁ
    - 두배의 저장공간 = 비용이 두배 = 공간효율이 나쁨
    - 저장속도(성능)은 변함 없음
    - 중요한 데이터를 저장하기에 적절함
    - 돈 많으면 가장 안전한 저장방식(미러링을 2개 3개 ... 씩)

    ![](https://2.bp.blogspot.com/-hLFaxJbOpec/Wq5UAr4G7CI/AAAAAAAABng/yT9uRRmUE501Pny4AUHGO6cvzGRwQz2ZgCLcBGAs/s1600/RAID%2B1.png)

  - RAID0 vs RAID1

    | 구분                     | RAID 0                 | RAID 1              |
    | ------------------------ | ---------------------- | ------------------- |
    | 성능                     | 뛰어남                 | 변화 없음           |
    | 데이터 안전성(결함 허용) | 보장 못함(결함 허용 X) | 보장함(결함 허용 O) |
    | 공간 효율성              | 좋음                   | 나쁨                |

  - RAID5 = RAID 0 + One Parity

    - RAID1의 데이터의 안전성 + RAID0처럼 공간 효율성
    - 최소한 3개 이상의 하드디스크가 필요
    - 오류가 발생할 때는 "패리티(Parity)"를 이용해서 데이터를 복구

    ![](https://4.bp.blogspot.com/-OVN9myYjopk/Wq5UG8VAfdI/AAAAAAAABnk/C3rCJEOR_YQouf4iKbXeUtThRe62GptJACLcBGAs/s1600/RAID%2B5.png)

  - RAID6 = RAID0 + two parity

    - RAID5 방식을 개선한 것으로 공간 효율은 RAID5보다

    ![](https://2.bp.blogspot.com/-qH5oDczy1aI/Wq5UKnIXOFI/AAAAAAAABno/gED9fKxD5gMCh43xFnVRuh8z0fcepvIrACLcBGAs/s1600/RAID%2B6.png)

  - 실습

    - 디스크 9개 추가 생성

      VMware 설정 - ADD - Hard Disk - SCSI - Create a new virtual disk - 2GB, Store virtual disk as a single file - 'disk0-1.vmdk' - Finish

      disk0-2.vmdk~disk0-10.vmdk 까지는 1GB로 설정 (SCSI 0:7은 VMware에서 예약되어 사용할 수 없으므로 disk0-7.vmdk는 생략)

    - 각각의 디스크를 파티셔닝

      \# fdisk /dev/sdb → [SCSI 0:1] 하드디스크 선택

      Command : n → 새로운 파티션 분할

      Select : p → Primary 파티션 서택

      Pratition number : 1 → 파티션 번호 1번 선택

      First sector : Enter → 시작 섹터 번호

      Last sector : Enter → 마지막 섹터 번호

      **Command : t → 파일 시스템 유형 선택**

      **Hex Code : fd → 'Linux raid autodetect' 유형 번호 (L을 입력하면 전체 유형 리스트 출력)**

      Command : p → 설정 내용 확인

      Command : w → 설정 저장

      

      이 과정을 /dev/sdb~/dev/sdj까지 9번 반복

    - RAID 구축을 위한 패키지 설치

      **apt-get -y install mdadm**

    - RAID 구축

      - Linear RAID 구축

        1. Linear RAID의 파티션 생성

           **mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1** → RAID생성

           ※ RAID의 종류와 파티션 이름을 일치시켜주어서 보기 쉽게 해주자. linear의 경우 비어 있는 9번을 사용

           **mdadm --detail --scan** → RAID 확인

        2. Linear RAID의 파티션에 파일시스템을 설정

           **mkfs.ext4 /dev/md9** or

           **mkfs -t ext4 /dev/md9 **

        3. Linear RAID를 마운트를 해보자.

           **mkdir /raidLinear** → 마운트할 디렉터리 생성

           **mount /dev/md9 /raidLinear** → 생성한 디렉터리에 마운트

           **df** → 현재 마운트된 RAID 확인 가능

           **vi /etc/fstab**

           ​	**/dev/md9 /raidLinear ext4 defaults 0 0** 를 마지막에 추가해주자. → /etc/fstab 파일은 	리눅스가 부팅될 때 마다 자동으로 읽는 중요한 파일이다. 이 파일에는 마운트 정보가 수록	되어 있으며, 글자가 틀릴 경우 아예 부팅이 되지 않을 수 있으므로 수정 시에는 주의를 요	한다.

           **mdadm --detail /dev/md9** → 구축한 RAID를 자세히 확인할 수 있음

      - RAID 0 구축

        1. RAID 0의 파티션 생성

           **mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1** → RAID생성

           **mdadm --detail --scan** → RAID 확인

        2. RAID 0의 파티션에 파일시스템을 설정

           **mkfs.ext4 /dev/md0** or

           **mkfs -t ext4 /dev/md0 **

        3. RAID 0를 마운트를 해보자.

           **mkdir /raid0** → 마운트할 디렉터리 생성

           **mount /dev/md0 /raid0** → 생성한 디렉터리에 마운트

           **df** → 현재 마운트된 RAID 확인 가능

           **vi /etc/fstab**

           ​	**/dev/md0 /raid0 ext4 defaults 0 0** 를 마지막에 추가해주자.

           **mdadm --detail /dev/md0** → 구축한 RAID를 자세히 확인할 수 있음

      - RAID 1 구축

        1. RAID 1의 파티션 생성

           **mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1** → RAID생성

           'Continue creating array?' 메시지가 나오면 y를 입력해서 계속 진행한다.

           **mdadm --detail --scan** → RAID 확인

        2. RAID 1의 파티션에 파일시스템을 설정

           **mkfs.ext4 /dev/md1** or

           **mkfs -t ext4 /dev/md1 **

        3. RAID 1를 마운트를 해보자.

           **mkdir /raid1** → 마운트할 디렉터리 생성

           **mount /dev/md1 /raid1** → 생성한 디렉터리에 마운트

           **df** → 현재 마운트된 RAID 확인 가능

           **vi /etc/fstab**

           ​	**/dev/md1 /raid1 ext4 defaults 0 0** 를 마지막에 추가해주자.

           **mdadm --detail /dev/md1** → 구축한 RAID를 자세히 확인할 수 있음

      - RAID 5 구축

        1. RAID 5의 파티션 생성

           **mdadm --create /dev/md5 --level=5 --raid-devices=3 /dev/sdh1 /dev/sdi1 /dev/sdj1** → RAID생성

           **mdadm --detail --scan** → RAID 확인

        2. RAID 5의 파티션에 파일시스템을 설정

           **mkfs.ext4 /dev/md5** or

           **mkfs -t ext4 /dev/md5 **

        3. RAID 5를 마운트를 해보자.

           **mkdir /raid5** → 마운트할 디렉터리 생성

           **mount /dev/md5 /raid5** → 생성한 디렉터리에 마운트

           **df** → 현재 마운트된 RAID 확인 가능

           **vi /etc/fstab**

           ​	**/dev/md5 /raid5 ext4 defaults 0 0** 를 마지막에 추가해주자.

           **mdadm --detail /dev/md5** → 구축한 RAID를 자세히 확인할 수 있음

      - 재부팅 전에 버그 방지를 위한 몇 가지 설정

        1. **mdadm --detail --scan** 명령으로 4개 ARRAY 내용을 복사한다.
        2. **/etc/mdadm/mdadm.conf** 파일에 붙여넣고 중간 부분에 있는 'name=server:숫자' 부분은 삭제하고 저장한다.
        3. **update-initramfs -u** 명령으로 설정한 내용을 적용시킨다.
        4. 재부팅을 한다.
        5. ls -l /dev/md* 명령와 df 명령으로 RAID 장치를 확인해 보자.