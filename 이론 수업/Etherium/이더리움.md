rpcapi → 사용할 명령어 설정



```cmd
C:\1blockchain\1etherium\3metacoin λ truffle develop

truffle(develop)> compile
....
truffle(develop)> migrate
.....
truffle(develop)> var instance=await MetaCoin.deployed()
undefined
truffle(develop)> var accounts = await web3.eth.getAccounts() ← await을 사용하여 변수 값 지정을 비동기함수가 완료될 때 까지 기다려준다.
undefined
truffle(develop)> var balance1 = await instance.getBalance(accounts[0])
undefined
truffle(develop)> balance1
<BN: 2710>
truffle(develop)> accounts
[ '0x1E1284881e3C0698711d8A2c425796ebe8F51cec',
  '0xd4D4224467111d9FE3f51Fdd751B9054fC60541B',
  '0x9c473E1fA362c6A16442571d92f1a0bDeaEaB69a',
  '0xC4dfD7098447660a89371432EFf6287f81b2f6c3',
  '0x13f8D972EDd9fb6Ce3cbf40Ee2a546f621F34F46',
  '0xdfED916aD3f89842729d2753742483d631dBDD48',
  '0x0Bf6C84696Bec3B3999a039A88DE38E92545Bd9E',
  '0x70d00F6a33A449CB2159c2152d158a03a5F71674',
  '0x83D34Bc1EE875394bC4508f46DfE5975E2a4a442',
  '0xc3EA00758eC5e9498D155C75bC4333Abd938F087' ]
truffle(develop)> balance1.toNumber()
10000
truffle(develop)> var balance2 = await instance.getBalance(accounts[1])
undefined
truffle(develop)> balance2.toNumber()
0
truffle(develop)> instance.sendCoin(accounts[1], 1000)
.....
truffle(develop)> balance2.toNumber() ← 변수로 선언해준 balance2값이기 때문에 고정되어 있어서 갱신(다시 선언)을 해줘야 전송을 확인할 수 있다.
0
truffle(develop)> var balance2 = await instance.getBalance(accounts[1])
undefined
truffle(develop)> balance2.toNumber()
1000
```

abi: application bytecode interface

```cmd
C:\1blockchain\1etherium\4vote
λ truffle unbox react
truffle compile
...
truffle migrate --network develop
...
yarn install
...
yarn start
...

cd client/
```



smart contract(이더리움, 하이퍼레저에서는 체인 코드?)를 다른곳에서 사용할 수 있게 해주는 도우미 Stub



truffle

compile을 통해 컨트랙트solidity파일을 바이트코드화 해주고 migrate를 통해 ganache로 생성한 이더리움 네트워크에 배포를 해준다. 이더리움 네트워크에 배포된 컨트랙트를 web3(stub)를 사용해서 가져와서 사용한다(이 통신에 사용하는게 rpc이고 이를 도와주는 도우미 역할로 skeleton과 stub이 있다).



# 하이퍼레져

[https://developer.ibm.com/kr/cloud/blockchain/blockchain-special-series/2018/11/11/hyperledger-fabric-architecture-3-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EA%B0%80-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/](https://developer.ibm.com/kr/cloud/blockchain/blockchain-special-series/2018/11/11/hyperledger-fabric-architecture-3-컴포넌트가-만드는-네트워크/)

끊임없이 신원확인을 한다.(정말로 이 블록체인의 멤버가 맞는지) p.49

- 여기에 MSP를 사용

멤버쉽 - 구성 방법, 채널별 구성 방법, 멤버쉽 레벨 p.57

Peers - node역할(각각의 컴퓨터들) p.66

Private data - 같은 채널에 있는 조직 피어에게 데이터를 공개하지 않는 방법 p.81

- Privacy - 채널들끼리는 서로 알 수 없다.

Ledger - 원장 p.85

개발환경 구축 p.94

튜토리얼 (First Network + FabCar) p.105

Marbles Demo - 자산 이동에 관한 데모

Orderer - 트랜잭션 풀에서 순서대로 여러 트랜잭션을 받아서 블럭을 생성해서 맞는 채널의 모든 피어에 전달해준다 (채널마다의 트랜잭션 풀이 있는데 이를 토픽(Queue 형식)이라한다 - 한 블럭에 몇개의 트랜잭션을 넣을지 정함(하이퍼레저에서의 합의에서)).

Ledger 구조

- W(World State): 최신 트랜잭션들의 상태 정보 - 빠르게 최신 정보에 엑세스하려고 - 원장까지 가지않고 접근 가능.
- B: 블록들의 체인



Peer

- endorser
  - 트랜잭션을 확인 = 거래 보증을 확인해서 응답해준다.(최소 1개 노드 이상. 다수의(?) endorser들이 틀리다고 판단하면 잘못된 거래로 판단)
  - 거래를 실행하는 노드
- commiter
  - 원장 갱신을 해줌(모든 Peer가 commiter가 되어야 한다).
  - 거래를 확정해서 블록체인에 저장하게 하는 노드
- blockchain
- peer 명령어 중
  - query는 world state에 접근하는 것이라 기록이 남지 않는다
  - invoke는 조회이든 수정이든 원장에 접근(transaction으로 동작)하는 것이라 기록이 남는다.



cli> peer chaincode install -n jes -v 1.0 -p github.com/sacc (🡺jes라는 이름으로 sacc를 설치한다)

이 부분에서 체인코드를 설치한 것이다. 공유볼륨인 ~/HLF/fabric-samples/chaincode에서 확인할 수 있다.

### 하이퍼레져 흐름

1. cli 명령
2. peer tx 수행 전달
3. orderer 박싱
4. peer 원장에 반영
5. 원장 업데이트 후 world state에 저장(CouchDB)

(모든 과정에서 신원확인 CA) 

install 은 peer에 chaincode를 설치할 뿐 orderer가 인식하지 못한다. instantiate를 해야 채널에 연결되고 orderer가 알 수 있다.

원장 file인 blockfile은 채널 당 하나만 생성된다. 그림상 C1의 L1. 같은 채널에 새로운 chaincode가 설치되어도 원장은 하나만 생성된다.