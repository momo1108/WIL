책 그대로

## 1. 안전한 소프트웨어 개발 방법론

> ### 1. 시큐어 코딩의 개요
>
> ### 2. 개발보안 방법론



## 2. 안전한 소프트웨어를 만드는 시큐어코딩 기법

> ### 3. 웹 애플리케이션 보안을 위한 기본 지식
>
> ### 4. 보안취약점 제거를 위한 코딩 기법
>
> ### 5. 안전하지 않은 코딩 스타일



## 3. 소프트웨어 보안 강화 기법

> ### 6. 오픈소스 보안 라이브러리 활용
>
> ### 7. 보안약점 진단 도구 활용

### 		　

### 1-1 시큐어코딩의 개요

- 소프트웨어 개발보안의 필요성
- 침해 사고 사례
- 보안취약점 정보 활용
- 행정자치부 소프트웨어 개발보안 가이드



#### 파일 업로드 취약점(개인정보 유출의 가장 큰 원인)

- 파일 업로드 기능을 제공하는 사이트에서업로드 파일의 크기와 개수를 제한하지 않음
  - 서버의 연결 및 디스크 자원을 고갈시킨다. ⇒ 정상적인 서비스를 방해 ⇒ DoS
- 업로드 파일의 종류를 제한하지 않음
  - 서버에서 실행 가능한 웹쉘(WebShell) 파일을 업로드 후 해당 파일을 실행해서 서버의 제어권을 탈취
  - 악성코드가 포함된 실행파일을 업로드 후 불특정 다수가 다운로드하도록 유도 ⇒ 악성코드 유포지로 악용
- 외부에서 접근 가능한 경로에 파일을 저장하는 경우에 발생하는 취약점

#### 방어기법

- 업로드 파일의 크기와 개수를 제한
- 업로드 파일의 종류를 제한
- 외부에서 접근할 수 없는 경로에 업로드 파일을 저장
- 업로드 파일의 저장 경로와 파일명을 외부에서 알 수 없도록 한다.
- 업로드 파일의 실행 속성을 제거한 후 저장한다.



#### SSL

취약점 : Heart Bleed https://blog.alyac.co.kr/76



#### SQL Injection

- SQL 명령에 사용된 특별한 엘리먼트를 무효화하지 않는 것 (SQL Injection)
- SQL문 예약어 또는 특수기호 ⇒ 메타문자(어떤 기능에서 의미를 가지고 있는 문자)
- 이스케이프 = 메타문자(의미문자)에서 의미를 제거하고 문자만 남기는 것
- 외부 입력값을 쿼리 조작 문자열 포함 여부를 확인하지 않고, 쿼리 생성 및 실행에 사용하는 경우 발생 → 원리 의미와 다른 형태로 쿼리가 변형되어서 실행되는 것 



#### 운영체제 명령어 삽입 (Command Injection)

- 운영체제 명령어 실행 부분이 존재하는 경우, 외부 입력값을 검증, 제한하지 않고, 명령어 또는 명령어의 일부로 사용하는 경우 발생

  ```java
  // 외부 입력값을 검증, 제한하지 않고, 명령어로 사용하는 경우
  String cmd = request.getParameter("cmd");
  Runtime.getRuntime().exec(cmd); 
  
  // 외부 입력값을 검증, 제한하지 않고, 명령어의 일부(명령어의 파라미터)로 사용하는 경우 ⇒ 의도하지 않은 추가 명령어 실행이 가능
  String file = request.getParameter("file");
  Runtime.getRuntime().exec("type c:\\data\" + file); 
  // c:\\data\ 아래에 존재하는 파일의 내용을 콘솔에 출력
  ```



#### 크로스 사이트 스크립팅(XSS = Cross-site Scripting)

- <u>웹 페이지 생성</u>에 사용된 <u>입력값 검증이 이뤄지지 않은 것</u>
  - 동적 페이지
  - 입력값이 페이지 생성에 사용되었음
  - 입력값에 실행 가능한 코드가 포함되었음

- <u>공격자가 전달한 스크립트 코드</u>가 사용자 브라우저를 통해서 실행되는 것
  1. 저장 XSS (Stored)
  2. 반사 XSS (Reflective)

![](./image/1.jpg)

```jsp
<%
	// 입력값에 포함된 태그 요소(< >)를 HTML 인코딩 처리해서 출력한다.
	// <script>..</script> ⇒ &lt;script&gt;..&lt;/script&gt;
	String input = request.getParameter("id");
	if (input != null) {
		input = input.replaceAll("<", "&lt;");
		input = input.replaceAll(">", "&gt;");
	}
%>
"<%=input>"는 존재합니다.
```



#### 사이트간 요청위조 = 크로스 사이트 요청위조 = CSRF(Cross-Site Request Forgery)

- 요청을 받은 서버측 프로그램이 요청 주체와 요청 절차를 검증하지 않고 요청을 처리했을 때 발생

![](./image/2.jpg)



#### Open Redirect 

- 신뢰되지 않은 URL 주소로 자동 접속 연결외부 입력값을 검증, 제한 없이 리다이렉트 주소로 사용하는 경우 발생
-  의도하지 않은(계획되지 않은) 외부 사이트로 리다이렉션이 발생할 수 있음

![](./image/3.jpg)

mypage.jsp
요청 : mypage.jsp?url=main.jsp ⇒ 응답 : main.jsp 

```jsp
<%@ page language="java" contentType="text/html; charset=EUC-KR"
    pageEncoding="EUC-KR"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
<title>Insert title here</title>
</head>
<body>
여기는 redirect.jsp 입니다.
<%
	String url = request.getParameter("url");
	if(url != null) {
		response.sendRedirect(url);
	}
%>
</body>
</html>
```

http://localhost:8080/openeg/Redirect.jsp?url=cors.html

- url을 직접 입력해주면 그쪽으로 redirect됨



#### 경로추적외부

- 입력값을 경로조작 문자열 포함 여부를 확인하지 않고, 내부 파일 참조에 사용하는 경우 발생
  - 정상 요청 : download.jsp?file_name=abc.gif ⇒ /upload/data/2019/08/abc.gif 파일을 다운로드 처리
  - 비정상 요청 : download.jsp?file_name=../../../../../../../../../etc/passwd ⇒ /ect/passwd 파일을 다운로드 처리
- 권한 밖의 파일에 접근이 가능
- 지정된 경로 밖의 파일에 접근이 가능



### 위협 모델링

1. 팀소집 - 팀원, 팀리더
2. 어플리케이션 **분해** → 위협목표 식별
3. ★★★**위협결정(위협트리)** ← **분류(STRIDE)** ← 식별
4. ★★★**위험도 산정(DREAD)** → 우선순위 결정
5. 대응방법 결정 : 무시, 알림, 고침(기능을 수정해서 사용가능), 제거(기능자체를 삭제)
6. 적용 기법·기술 선택



cgi → servlet → mvc 프레임워크



### 웹 인증 방식

쿠키(Cookie)

1. **쿠키에 중요정보를 포함하지 않는다. ☞ 쉽게 노출, 유출되고, 위변조가 가능하므로**

2. **중요정보를 포함하는 경우, 반드시 암호화한다.**

3. **유효기간(Expires), 지속시간(MaxAge)**
   - 길게 설정된 경우 → 사용자 하드디스크(의 브라우저 영역)에 파일로 저장 = 디스크 쿠키, Persistence(영구적) Cookie
   - 설정되지 않거나 짧게 설정된 경우 → **메모리에 저장 = Memory, Session Cookie** (이 방식이 더 안전)
4. **보안(Secure)**
   - 설정된 경우 → 보안 쿠키 = HTTPS 통신인 경우에만 서버로 전달(중요한 정보는 필요할 때만 왔으면 좋겠다.)
   - 설정되지 않은 경우 → 비보안 쿠키
5. **HttpOnly**
   - 클라이언트(브라우저)에서 쿠키에 접근을 차단**(쿠키가 털리는 경우 - 1. 네트워크 부분: 통신중의 쿠키가 노출→보안 쿠키를 이용해서 예방(https - SID도 암호화되므로 털려도 읽기 힘들다), 2. 브라우저: 브라우저의 메모리, 하드디스크가 털리는 경우 → HttpOnly옵션을 활성화)**
   - 모든 브라우저에서 지원하지 않음

- HTTP는 다른 프로토콜들처럼 연결을 유지하지 않기 때문에 app에서 직접 연결을 유지하기 위한 프로그래밍을 해준다.
- 도착한 요청이 전에온 놈인지 구분하기 위해(요청과 요청에 연관성을 나타내기 위한 첫번째 수단) 요청에 붙어온 쿠키를 확인해서 자신이 부여해준 쿠키(Set-Cookie 헤더를 통해 생성)인지 확인한다.
- 쿠키에 관련된 일들은 브라우저가 해주고 사용자의 관여를 없애준다. 연결이 유지되는 것처럼 착각하게 만들어준다. 사용자는 요청 파라미터를 사용해서 관계를 알려준다.

- 한번 저장된 쿠키는  유효기간이 경과하지 않았다면 해당 도메인에 접속하면 브라우저가 자동으로 탑재하여 전송

**세션이란? 요청과 요청이 연관이 있다는 것을 알려주는 역할을 한다.**

#### 세션을 사용하지 않는 HTTP 인증

- Basic Authentication - **Basic 64로 인코딩해서 안전하지 않다. 연결을 유지하지 않기 때문에 연결할때마다 인증정보를 계속 가져가야 한다.(세션을 유지하지 않기 때문에☞인증 정보를 계속 달고가기 때문에 유출가능성이 높아진다.)**

- HTTP Digest Authentication - 서버가 임의의 값(nonce)을 준 후 해쉬를 돌리고 클라이언트가 해쉬를 돌려서 res에 같이 보내준 값과 비교하여 인증을 한다.

  ![](./image/4.gif)

- HTTP NTLM Authentication - 인터넷 익스플로러

- Anonymous Authentication

#### 세션을 사용하는 인증

- Form Based Authentication - **인증에 성공하면 세션을 생성한다. 그 후 요청엔 쿠키를 통해 전달되는 SID(세션 ID)만 가지고 인증을 해준다.**

- **안전한 세션 ID(SID) 생성 및 관리 규칙**
  1. 세션 ID 생성 규칙을 유추할 수 있으면 안됨 → 세션 ID 추측 공격이 가능 = 이전에 생성된 세션 ID 또는 이후에 생성될 세션 ID를 예측하여 공격자가 설정하고 대기
  2. 세션 ID가 인증전과 인증후 다르게 생성되어야 한다. → 세션 ID 고정 공격이 가능 = 공격자(사이트에 접속 권한 없음)가 발급 받은 세션 ID를 희생자(사이트에 접속 권한이 있음)에게 설정 후 희생자가 로그인하면 공격자도 로그인된 상태를 가지게 됨
  3. 서버로부터 발급받은 세션 ID를 훔쳐가는 것을 방지 → 세션 ID 훔치기 공격이 가능 = XSS 공격 또는 스니핑 등의 공격을 통해서 세션ID를 훔쳐감



### 인코딩

데이터를 일정한 규칙에 따라 바꾸는 것

- ASCII
- URL Encoding(클라이언트가 서버에게 데이터를 그대로 보내기위해 사용)
- HTML Encoding(서버가 클라이언트에게 데이터를 그대로 보내기위해 사용)
- BASE64 Encoding - 텍스트만 전송되던 메일 프로토콜에서 파일을 전송하기 위해 binary 데이터를 텍스트화해서 전송할 수 있도록 해준다.(8비트 2진 데이터를 문자코드에 영향을 받지 않는 ASCII 문자열로 바꾸는 인코딩 방식-SMTP 이메일 첨부 파일 전송, HTTP 기본 인증에 사용)



### 정규식

문자열의 검색, 치환, 추출을 위해 사용되는 패턴